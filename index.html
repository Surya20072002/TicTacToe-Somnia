<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Somnia Tic Tac Toe</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ethers.js CDN is now dynamically loaded by JavaScript -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0; /* Light text */
        }
        .game-container {
            background-color: #2d3748; /* Darker background for container */
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            text-align: center;
            max-width: 90%; /* Keep this for responsiveness */
            width: 600px; /* Increased width */
            display: flex; /* Use flexbox for vertical arrangement */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 0.5rem;
            width: 100%;
            max-width: 450px; /* Adjusted to scale with container */
            margin: 1.5rem auto; /* Adjusted margin */
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .cell {
            width: 100%;
            height: 150px; /* Increased height for cells to match width increase */
            background-color: #4a5568;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4.5rem; /* Increased font size for X/O */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border-radius: 0.375rem; /* rounded-md */
            color: #cbd5e0;
        }
        .cell:hover:not(.occupied) {
            background-color: #6a7587;
        }
        .cell.occupied {
            cursor: not-allowed;
        }
        .cell.x {
            color: #a0aec0; /* Light blue-gray for X */
        }
        .cell.o {
            color: #f6ad55; /* Orange for O */
        }
        .message-box {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem; /* Adjusted margin */
            margin-bottom: 1rem; /* Added margin */
            font-weight: 600;
            min-height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%; /* Ensure it spans full width */
        }
        .button-group button {
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .button-group button:hover {
            transform: translateY(-2px);
        }
        .button-group button:active {
            transform: translateY(0);
            box-shadow: none;
        }
        .bet-button.selected {
            background-color: #8b5cf6 !important; /* Purple for selected bet */
            color: white !important;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="game-container">
        <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">Somnia Tic Tac Toe</h1>

        <div id="gameMessage" class="message-box">Connecting wallet...</div>

        <div class="flex flex-col items-center w-full mb-6 p-4 bg-gray-700 rounded-lg shadow-inner">
            <!-- Wallet Balance on the first line -->
            <div class="flex justify-center items-center mb-4 gap-4 w-full">
                <div class="text-xl font-semibold">
                    Wallet Balance: <span id="walletBalanceDisplay" class="text-yellow-400">-- STT</span>
                </div>
            </div>
            <!-- Bet buttons on the second line, wrapping on smaller screens -->
            <div class="flex flex-wrap justify-center gap-2 w-full">
                <button class="bet-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50" data-bet="0">Free</button>
                <button class="bet-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50" data-bet="0.001">0.001 STT</button>
                <button class="bet-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50" data-bet="0.05">0.05 STT</button>
                <button class="bet-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50" data-bet="1">1 STT</button>
            </div>
        </div>

        <div id="gameBoard" class="board">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>

        <div class="button-group flex justify-center gap-4 mt-6">
            <button id="newGameButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">New Game</button>
        </div>
    </div>

    <script>
        // Game state variables
        let board = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X'; // 'X' for user, 'O' for AI
        let gameActive = false;
        let simulatedBalance = 10.00; // Starting simulated balance for STT (retained for internal game logic)
        let currentBet = 0; // Default to Free bet
        const aiRandomMoveChance = 0.12; 

        // Somnia Testnet details
        const SOMNIA_CHAIN_ID = 50312;
        const SOMNIA_RPC_URL = 'https://dream-rpc.somnia.network/';
        const SOMNIA_BLOCK_EXPLORER_URL = 'https://shannon-explorer.somnia.network/';
        const SOMNIA_SYMBOL = 'STT';
        const SOMNIA_CHAIN_NAME = 'Somnia Testnet';

        // Contract Details
        const CONTRACT_ADDRESS = '0xC4183de6375b46A35077AaC19cf41B5A01A9cefa';
        const CONTRACT_ABI = [
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_player",
                        "type": "address"
                    },
                    {
                        "internalType": "string",
                        "name": "_outcome",
                        "type": "string"
                    }
                ],
                "name": "declareOutcome",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_initialBetAmount",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "required",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "provided",
                        "type": "uint256"
                    }
                ],
                "name": "InsufficientFunds",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "expected",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "provided",
                        "type": "uint256"
                    }
                ],
                "name": "InvalidBetAmount",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "string",
                        "name": "outcome",
                        "type": "string"
                    }
                ],
                "name": "InvalidOutcome",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    }
                ],
                "name": "NoActiveBet",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "placeBet",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_newBetAmount",
                        "type": "uint256"
                    }
                ],
                "name": "setBetAmount",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "caller",
                        "type": "address"
                    }
                ],
                "name": "Unauthorized",
                "type": "error"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "BetPlaced",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "to",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "FundsWithdrawn",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "outcome",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "payout",
                        "type": "uint256"
                    }
                ],
                "name": "OutcomeDeclared",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "withdraw",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            },
            {
                "inputs": [],
                "name": "betAmount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "playerActiveBet",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        let provider;
        let signer;
        let userAddress;
        let ticTacToeContract;

        // DOM elements
        const cells = document.querySelectorAll('.cell');
        const gameMessage = document.getElementById('gameMessage');
        const walletBalanceDisplay = document.getElementById('walletBalanceDisplay'); 
        const newGameButton = document.getElementById('newGameButton');
        const betButtons = document.querySelectorAll('.bet-button');

        // Winning conditions (indices of cells that form a win)
        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        /**
         * Initializes the game state and UI.
         */
        function initializeGame() {
            board = ['', '', '', '', '', '', '', '', ''];
            currentPlayer = 'X'; // User always starts
            gameActive = true;
            gameMessage.textContent = `Player X's turn (You). Current bet: ${currentBet === 0 ? 'Free' : currentBet + ' STT'}.`;
            
            // Clear cell content and classes
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('x', 'o', 'occupied');
                cell.addEventListener('click', handleCellClick, { once: true }); // Re-add event listener
            });
        }

        /**
         * Fetches and updates the connected wallet's STT balance.
         */
        async function updateWalletBalanceDisplay() {
            if (provider && userAddress) {
                try {
                    const balanceWei = await provider.getBalance(userAddress);
                    const balanceEth = ethers.utils.formatEther(balanceWei);
                    walletBalanceDisplay.textContent = `${parseFloat(balanceEth).toFixed(4)} STT`;
                } catch (error) {
                    console.error("Error fetching wallet balance:", error);
                    walletBalanceDisplay.textContent = `Error`;
                }
            } else {
                walletBalanceDisplay.textContent = `-- STT`;
            }
        }

        /**
         * Handles a click on a Tic Tac Toe cell.
         * @param {Event} event - The click event object.
         */
        function handleCellClick(event) {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            // If the cell is already occupied or game is not active, do nothing
            if (board[clickedCellIndex] !== '' || !gameActive) {
                return;
            }

            // Place 'X' (user's move)
            board[clickedCellIndex] = currentPlayer;
            clickedCell.textContent = currentPlayer;
            clickedCell.classList.add('occupied', 'x');

            // Check for game outcome after user's move
            if (checkWin()) {
                gameMessage.textContent = `Congratulations! You (X) won! You get ${currentBet === 0 ? 'nothing extra' : (currentBet * 2).toFixed(3) + ' STT'}!`;
                if (currentBet > 0) {
                    // In a real dApp, the contract owner would call declareOutcome(userAddress, "win") here
                    // declareGameOutcome(userAddress, "win"); // This would be called by the contract owner
                }
                gameActive = false;
                disableCells();
                return;
            }

            if (checkDraw()) {
                gameMessage.textContent = `It's a draw! Your bet of ${currentBet === 0 ? 'Free' : currentBet + ' STT'} is returned.`;
                if (currentBet > 0) {
                    // In a real dApp, the contract owner would call declareOutcome(userAddress, "draw") here
                    // declareGameOutcome(userAddress, "draw"); // This would be called by the contract owner
                }
                gameActive = false;
                disableCells();
                return;
            }

            // Switch to AI's turn
            currentPlayer = 'O';
            gameMessage.textContent = `Player O's turn (AI).`;
            setTimeout(handleAIMove, 700); // Delay AI move for better UX
        }

        /**
         * Finds the best move for the AI (O) or player (X) to win or block.
         * @param {string} player - The player to check for ('X' or 'O').
         * @returns {number | null} - The index of the winning/blocking move, or null if none.
         */
        function findWinningMove(player) {
            for (let i = 0; i < winningConditions.length; i++) {
                const [a, b, c] = winningConditions[i];
                const line = [board[a], board[b], board[c]];

                // Check if two cells are occupied by 'player' and the third is empty
                if (line.filter(cell => cell === player).length === 2 && line.includes('')) {
                    if (board[a] === '' && board[a] !== (player === 'X' ? 'O' : 'X')) return a;
                    if (board[b] === '' && board[b] !== (player === 'X' ? 'O' : 'X')) return b;
                    if (board[c] === '' && board[c] !== (player === 'X' ? 'O' : 'X')) return c;
                }
            }
            return null;
        }

        /**
         * Handles the AI's move with a basic strategic approach, with a chance for a random move.
         */
        function handleAIMove() {
            if (!gameActive) return;

            const availableCells = [];
            for (let i = 0; i < board.length; i++) {
                if (board[i] === '') {
                    availableCells.push(i);
                }
            }

            if (availableCells.length === 0) {
                // This case should ideally be caught by checkDraw before AI moves
                return;
            }

            let aiMoveIndex = null;

            // Introduce randomness: AI makes a random move with a certain probability
            if (Math.random() < aiRandomMoveChance) {
                aiMoveIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
                makeAIMove(aiMoveIndex);
                return;
            }

            // Strategic AI moves
            // 1. Check if AI can win
            aiMoveIndex = findWinningMove('O');
            if (aiMoveIndex !== null && board[aiMoveIndex] === '') {
                makeAIMove(aiMoveIndex);
                return;
            }

            // 2. Check if player can win and block them
            aiMoveIndex = findWinningMove('X');
            if (aiMoveIndex !== null && board[aiMoveIndex] === '') {
                makeAIMove(aiMoveIndex);
                return;
            }

            // 3. Take the center if available
            if (board[4] === '') {
                aiMoveIndex = 4;
                makeAIMove(aiMoveIndex);
                return;
            }

            // 4. Take opposite corner if player has a corner
            const corners = [0, 2, 6, 8];
            const oppositeCorners = { 0: 8, 2: 6, 6: 2, 8: 0 };
            for (let i = 0; i < corners.length; i++) {
                const corner = corners[i];
                if (board[corner] === 'X' && board[oppositeCorners[corner]] === '') {
                    aiMoveIndex = oppositeCorners[corner];
                    makeAIMove(aiMoveIndex);
                    return;
                }
            }

            // 5. Take any empty corner
            const availableCorners = corners.filter(index => board[index] === '');
            if (availableCorners.length > 0) {
                aiMoveIndex = availableCorners[Math.floor(Math.random() * availableCorners.length)];
                makeAIMove(aiMoveIndex);
                return;
            }

            // 6. Take any empty side
            const sides = [1, 3, 5, 7];
            const availableSides = sides.filter(index => board[index] === '');
            if (availableSides.length > 0) {
                aiMoveIndex = availableSides[Math.floor(Math.random() * availableSides.length)];
                makeAIMove(aiMoveIndex);
                return;
            }

            // Fallback: If somehow no strategic move, pick a random available cell
            if (availableCells.length > 0) {
                aiMoveIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
                makeAIMove(aiMoveIndex);
                return;
            }

            // If no moves are left, it's a draw (this should be caught by checkDraw)
            if (checkDraw()) {
                gameMessage.textContent = `It's a draw! Your bet of ${currentBet === 0 ? 'Free' : currentBet + ' STT'} is returned.`;
                if (currentBet > 0) {
                    // In a real dApp, the contract owner would call declareOutcome(userAddress, "draw") here
                    // declareGameOutcome(userAddress, "draw"); // This would be called by the contract owner
                }
                gameActive = false;
                disableCells();
                return;
            }
        }

        /**
         * Executes the AI's chosen move and updates the board.
         * @param {number} index - The index of the cell for the AI's move.
         */
        function makeAIMove(index) {
            board[index] = 'O';
            cells[index].textContent = 'O';
            cells[index].classList.add('occupied', 'o');
            cells[index].removeEventListener('click', handleCellClick); // Prevent clicking AI's chosen cell

            // Check for game outcome after AI's move
            if (checkWin()) {
                gameMessage.textContent = `AI (O) won! You lost your bet of ${currentBet === 0 ? 'Free' : currentBet + ' STT'}.`;
                // In a real dApp, the contract owner would call declareOutcome(userAddress, "lose") here
                // declareGameOutcome(userAddress, "lose"); // This would be called by the contract owner
                gameActive = false;
                disableCells();
                return;
            }

            if (checkDraw()) {
                gameMessage.textContent = `It's a draw! Your bet of ${currentBet === 0 ? 'Free' : currentBet + ' STT'} is returned.`;
                if (currentBet > 0) {
                    // In a real dApp, the contract owner would call declareOutcome(userAddress, "draw") here
                    // declareGameOutcome(userAddress, "draw"); // This would be called by the contract owner
                }
                gameActive = false;
                disableCells();
                return;
            }

            // Switch back to user's turn
            currentPlayer = 'X';
            gameMessage.textContent = `Player X's turn (You).`;
        }

        /**
         * Checks if the current player has won the game.
         * @returns {boolean} - True if the current player has won, false otherwise.
         */
        function checkWin() {
            return winningConditions.some(condition => {
                const [a, b, c] = condition;
                return board[a] !== '' && board[a] === board[b] && board[a] === board[c];
            });
        }

        /**
         * Checks if the game is a draw.
         * @returns {boolean} - True if the game is a draw, false otherwise.
         */
        function checkDraw() {
            return board.every(cell => cell !== '');
        }

        /**
         * Disables all cells to prevent further moves after game end.
         */
        function disableCells() {
            cells.forEach(cell => {
                cell.removeEventListener('click', handleCellClick);
                cell.classList.add('occupied'); // Visually mark as unclickable
            });
        }

        /**
         * Handles the selection of a bet amount.
         * @param {Event} event - The click event object.
         */
        function handleBetSelection(event) {
            // Remove 'selected' class from all buttons
            betButtons.forEach(button => button.classList.remove('selected'));

            // Add 'selected' class to the clicked button
            event.target.classList.add('selected');

            // Update currentBet
            currentBet = parseFloat(event.target.dataset.bet);
            gameMessage.textContent = `Bet selected: ${currentBet === 0 ? 'Free' : currentBet + ' STT'}. Click 'New Game' to start.`;
        }

        /**
         * Connects to the user's wallet and switches to Somnia Testnet.
         * @returns {Promise<boolean>} - True if connection and network switch are successful, false otherwise.
         */
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                gameMessage.textContent = 'MetaMask is not installed. Please install it to play.';
                gameActive = false;
                return false;
            }

            try {
                // Request account access
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                userAddress = accounts[0];
                console.log('Connected account:', userAddress);

                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner(); // Get the signer for sending transactions
                ticTacToeContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                const network = await provider.getNetwork();

                if (network.chainId !== SOMNIA_CHAIN_ID) {
                    gameMessage.textContent = 'Switching to Somnia Testnet...';
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: ethers.utils.hexlify(SOMNIA_CHAIN_ID) }],
                        });
                        // After switching, re-check network
                        const newNetwork = await provider.getNetwork();
                        if (newNetwork.chainId !== SOMNIA_CHAIN_ID) {
                            gameMessage.textContent = 'Failed to switch to Somnia Testnet. Please switch manually.';
                            gameActive = false;
                            return false;
                        }
                    } catch (switchError) {
                        // This error code indicates that the chain has not been added to MetaMask.
                        if (switchError.code === 4902) {
                            try {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: ethers.utils.hexlify(SOMNIA_CHAIN_ID),
                                        chainName: SOMNIA_CHAIN_NAME,
                                        rpcUrls: [SOMNIA_RPC_URL],
                                        nativeCurrency: {
                                            name: SOMNIA_CHAIN_NAME,
                                            symbol: SOMNIA_SYMBOL,
                                            decimals: 18,
                                        },
                                        blockExplorerUrls: [SOMNIA_BLOCK_EXPLORER_URL],
                                    }],
                                });
                                // After adding, re-check network
                                const newNetwork = await provider.getNetwork();
                                if (newNetwork.chainId !== SOMNIA_CHAIN_ID) {
                                    gameMessage.textContent = 'Failed to add Somnia Testnet. Please add manually.';
                                    gameActive = false;
                                    return false;
                                }
                            } catch (addError) {
                                gameMessage.textContent = `Failed to add Somnia Testnet: ${addError.message}`;
                                gameActive = false;
                                return false;
                            }
                        } else {
                            gameMessage.textContent = `Failed to switch network: ${switchError.message}`;
                            gameActive = false;
                            return false;
                        }
                    }
                }

                gameMessage.textContent = 'Wallet connected to Somnia Testnet! Select your bet and click New Game.';
                updateWalletBalanceDisplay(); // Update wallet balance after connection
                return true; // Wallet connected and on correct network
            } catch (error) {
                gameMessage.textContent = `Wallet connection failed: ${error.message}`;
                gameActive = false;
                return false;
            }
        }

        /**
         * Calls the placeBet function on the smart contract.
         * @param {number} betValue - The amount of STT to bet.
         * @returns {Promise<boolean>} - True if the transaction is successful, false otherwise.
         */
        async function placeBetOnContract(betValue) {
            if (!ticTacToeContract) {
                gameMessage.textContent = "Error: Contract not initialized. Connect wallet first.";
                return false;
            }

            try {
                let tx;
                if (betValue === 0) {
                    // For free games, call placeBet without sending value
                    tx = await ticTacToeContract.placeBet();
                } else {
                    // For paid bets, send the value in wei
                    const betAmountWei = ethers.utils.parseEther(betValue.toString()); // Convert STT to wei
                    
                    // Check if wallet balance is sufficient for the bet
                    const walletBalanceWei = await provider.getBalance(userAddress);
                    if (walletBalanceWei.lt(betAmountWei)) {
                        gameMessage.textContent = `Insufficient STT in wallet for this bet (${betValue} STT).`;
                        return false;
                    }

                    tx = await ticTacToeContract.placeBet({ value: betAmountWei });
                }
                
                gameMessage.textContent = `Placing bet on blockchain... Transaction hash: ${tx.hash}`;
                await tx.wait(); // Wait for the transaction to be mined
                gameMessage.textContent = `Bet placed successfully on blockchain! Starting game.`;
                updateWalletBalanceDisplay(); // Update wallet balance after bet is placed
                return true;
            } catch (error) {
                console.error("Error placing bet on contract:", error);
                let errorMessage = "Failed to place bet on blockchain.";
                if (error.code === 4001) { // User rejected transaction
                    errorMessage = "Transaction rejected by user.";
                } else if (error.data && error.data.message) {
                    errorMessage = `Failed to place bet: ${error.data.message}`;
                } else if (error.message) {
                    errorMessage = `Failed to place bet: ${error.message}`;
                }
                gameMessage.textContent = errorMessage;
                return false;
            }
        }

        /**
         * Placeholder for declaring game outcome on the smart contract.
         * In a real dApp, this would be called by the contract owner via an off-chain server or oracle.
         * @param {string} playerAddress - The address of the player.
         * @param {string} outcome - The outcome ("win", "lose", "draw").
         */
        async function declareGameOutcome(playerAddress, outcome) {
            console.log(`Simulating outcome declaration for ${playerAddress}, outcome: ${outcome}`);
            console.log("In a real dApp, the contract owner would call ticTacToeContract.declareOutcome(playerAddress, outcome) here.");
            // Example of how it *would* be called if the client was the owner:
            /*
            if (!ticTacToeContract) {
                console.error("Contract not initialized.");
                return;
            }
            try {
                const tx = await ticTacToeContract.declareOutcome(playerAddress, outcome);
                console.log(`Declaring outcome transaction sent: ${tx.hash}`);
                await tx.wait();
                console.log("Outcome declared and payout processed on blockchain.");
                updateWalletBalanceDisplay(); // Update wallet balance after payout
            } catch (error) {
                console.error("Error declaring outcome on contract:", error);
            }
            */
        }


        // Event Listeners
        newGameButton.addEventListener('click', async () => {
            const connected = await connectWallet();
            if (connected) {
                // Only attempt to place bet if a bet is selected (not free)
                if (currentBet > 0) {
                    const betSuccessful = await placeBetOnContract(currentBet);
                    if (betSuccessful) {
                        initializeGame();
                    }
                } else { // If Free game, just initialize
                    initializeGame();
                }
            }
        });

        betButtons.forEach(button => {
            button.addEventListener('click', handleBetSelection);
        });

        // Dynamically load Ethers.js and then initialize the game logic
        document.addEventListener('DOMContentLoaded', () => {
            betButtons[0].click(); // Simulate click on "Free" bet button
            gameMessage.textContent = 'Connecting wallet...'; // Initial message
            
            // Remove the static Ethers.js script tag from HTML head as it's loaded dynamically now
            const staticEthersScript = document.querySelector('script[src="https://cdn.ethers.io/lib/ethers-5.7.umd.min.js"]');
            if (staticEthersScript) {
                staticEthersScript.remove();
            }

            const script = document.createElement('script');
            script.src = 'https://cdn.ethers.io/lib/ethers-5.7.umd.min.js';
            script.onload = () => {
                if (typeof ethers !== 'undefined') {
                    connectWallet(); 
                    // Listen for account or network changes in MetaMask
                    if (typeof window.ethereum !== 'undefined') {
                        window.ethereum.on('accountsChanged', (accounts) => {
                            if (accounts.length > 0) {
                                userAddress = accounts[0];
                                updateWalletBalanceDisplay();
                                gameMessage.textContent = `Wallet connected: ${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}. Select your bet and click New Game.`;
                            } else {
                                userAddress = null;
                                updateWalletBalanceDisplay();
                                gameMessage.textContent = 'Wallet disconnected. Please connect to play.';
                            }
                        });
                        window.ethereum.on('chainChanged', (chainId) => {
                            console.log('Chain changed to:', chainId);
                            connectWallet(); // Re-run connection logic to ensure correct network
                        });
                    }
                } else {
                    gameMessage.textContent = 'Error: Ethers.js loaded but not defined. Try refreshing.';
                    console.error("Ethers.js is not defined after loading.");
                }
            };
            script.onerror = () => {
                gameMessage.textContent = 'Error: Failed to load Ethers.js. Please check your internet connection.';
                console.error('Failed to load script:', script.src);
            };
            document.head.appendChild(script);
        });

    </script>
</body>
</html>
